# Software Design Patterns - Assignment 3

This repository contains the third assignment for the Software Design Patterns course. The assignment focuses on the implementation and understanding of various design patterns, including Decorator, Factory, Command, Singleton, Observer, and Strategy patterns.

## Table of Contents
- [Introduction](#introduction)
- [Design Patterns](#design-patterns)
  - [Decorator](#decorator)
  - [Factory](#factory)
  - [Command](#command)
  - [Singleton](#singleton)
  - [Observer](#observer)
  - [Strategy](#strategy)
- [Usage](#usage)
- [Installation](#installation)
- [Contributing](#contributing)
- [License](#license)

## Introduction

In this assignment, you will find implementations of several key design patterns used in software engineering. These patterns are crucial for creating scalable, maintainable, and efficient software systems. The goal is to provide a clear and practical demonstration of each pattern through well-documented code examples.

## Design Patterns

### Decorator
The Decorator pattern is used to dynamically add behavior and responsibilities to objects without modifying their code. It provides a flexible alternative to subclassing for extending functionality.

### Factory
The Factory pattern is a creational pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. This pattern promotes loose coupling and enhances code maintainability.

### Command
The Command pattern is a behavioral pattern that turns a request into a stand-alone object that contains all information about the request. This pattern allows for parameterizing clients with queues, requests, and operations, and supports undoable operations.

### Singleton
The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance. This pattern is useful when exactly one object is needed to coordinate actions across the system.

### Observer
The Observer pattern is a behavioral pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes. This pattern is essential for implementing distributed event-handling systems.

### Strategy
The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern lets the algorithm vary independently from clients that use it, promoting code reuse and flexibility.

## Usage

To explore and understand each design pattern, navigate to the respective directory and review the provided code examples and documentation. Each pattern has a dedicated folder with sample code that demonstrates its usage and benefits.


